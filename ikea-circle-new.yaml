# Вариант без родного контроллера питание (+) 4 ножка (-) 2 ножка контроллера
########### st7735 ################
## SDA  GPIO23 D7   VSPI MOSI    ##
## SCLK GPIO18 D5   VSPI SCK     ##
## D/C  GPIO5  D8   DC           ##
## RST  GPIO1  RST  RESET        ##
## CS   GPIO26 D0   chip select  ##
## LED  GPIO19 D6                ##
###################################

#################### WEMOS D1 ESP32 ###############################
##  |GN|       |RS| reset    |#|     | 1| tuart    |GN|          ##
##  |NC|       |36|          |#|     | 3| ruart    |27|          ##
##  |39|       |26| cs       |#|     |22| scl      |25|          ##
##  |35|       |18| clk      |#|     |21| sda      |32|          ##
##  |33|       |19| led      |#|     |17| TTP223   |12|          ##
##  |34|       |23| mosi     |#|     |16| vent     | 4|          ##
##  |14|       | 5| dc       |#|     |GN|          | 0|          ## 
##  |NC|       |3V|          |#|     |5V|          | 2|          ##
##  | 9|       |13|          |#|     |15|          | 8|          ##
##  |11|       |10|          |#|     | 7|          | 6|          ##
###################################################################

substitutions:
  name: ikea
  device_description: "ikea"
  telegram_api_token: !secret telegram_bot
  telegram_chat_id: !secret chat_id_gora_r
  
esphome:
  name: "${name}"
  comment: "${device_description}"
  on_boot:
    priority: 240
    then:
      - uart.write:
          id: PM1006
          data: [0x11, 0x02, 0x0B, 0x01, 0xE1]
      - light.turn_on: lcd

esp32:
  board: wemos_d1_mini32

# Enable logging
logger:
# Enable Home Assistant API 
api:
  password: !secret api_pass
  reboot_timeout: 0s
#Включаем загрузку по воздуху
ota:
  password: !secret ota_pass
  platform: esphome
  
wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password

external_components:
  #    type: local
  #    path: my_components
 #   components: [ pm1006k ]
  - source: github://ananyevgv/esphome-components
    components: [pm1006k]
    refresh: 0s
 # - source: github://pr#6381
 #   components: [ display, font ]

color:
  - id: red
    hex: FF7F7F
  - id: tred
    hex: e50000

  - id: yellow
    red: 100%
    green: 100%
    blue: 0%

  - id: lyellow
    hex: ffa500

  - id: green
    red: 0%
    green: 100%
    blue: 0%

  - id: lgreen
    red: 70%
    green: 100%
    blue: 0% 

  - id: blue
    red: 0%
    green: 100%
    blue: 100%

  - id: white
    red: 100%
    green: 100%
    blue: 100%

  - id: black
    red: 0%
    green: 0%
    blue: 0%  
image:    
  - file: "picture/clok-240-300.jpg"
    id: clok
    resize: 128x160 
    type: RGB565 
   
  - file: "picture/barometr.jpg"
    id: barometr
    resize: 128x160 
    type: RGB565  


animation:
  - file: "picture/sun-wilao.gif"
    id: g_sun
    resize: 20x20
    type: RGB565
  - file: "picture/moon-ramadhan.gif"
    id: g_moon
    resize: 20x20 
    type: RGB565
  - file: "picture/fan.gif"
    id: g_fan
    resize: 20x20  

font:

  - file: "font/DSEG7ModernMini-Bold.ttf"
    id: SEG24
    size: 24
  - file: "font/DSEG7ModernMini-Bold.ttf"
    id: SEG12
    size: 12
  - file:
      type: gfonts
      family: Roboto
    id: font11
    size: 11
    glyphs: |-
      !"%()+=,-_.:³°₂μ0123456789АБВГДЕЁЖЗИЙКЛМНОПРСТУФХЦЧЩЬЫЪЭЮЯABCDEFGHIJKLMNOPQRSTUVWXYZ абвгдеёжзийклмнопрстуфхцчщьыъэюяabcdefghijklmnopqrstuvwxyz'éèàòùç/&ôœìïöñ
  - file:
      type: gfonts
      family: Roboto
    id: font0
    size: 15
    glyphs: |-
      !"%()+=,-_.:³°₂μ0123456789АБВГДЕЁЖЗИЙКЛМНОПРСТУФХЦЧЩЬЫЪЭЮЯABCDEFGHIJKLMNOPQRSTUVWXYZ абвгдеёжзийклмнопрстуфхцчщьыъэюяabcdefghijklmnopqrstuvwxyz'éèàòùç/&ôœìïöñ
    # gfonts://family[@weight]
  - file:
      type: gfonts
      family: Roboto
    id: font1
    size: 20
  - file:
      type: gfonts
      family: Roboto
      weight: 700
    id: font2
    size: 35  
  - file: 'gfonts://Material+Symbols+Outlined'
    id: icon_font
    size: 20
    glyphs: ["\U0000e846","\U0000e7b0","\U0000f176","\U0000ebdb","\U0000e430","\U0000e2bd","\U0000f87e"] 
#             термометр     СО           дождь       гроза        солнце                    влажность

i2c:
   sda: D2 #GPIO21
   scl: D1 #GPIO22
   scan: true

sun:
  latitude: !secret latitude
  longitude: !secret longitude

bme680_bsec:
  address: 0x77

uart:
  tx_pin: 3 #1 ножка контроллера
  rx_pin: 1 #8 ножка контроллера
  baud_rate: 9600
  id: PM1006
 
spi:
  clk_pin: D5 #GPIO18
  mosi_pin: D7 #GPIO23

binary_sensor:
  - platform: template
    name: "vent"
    id: vent_bin
    internal: true

  - platform: gpio
    pin: 17
    name: "LCD backlight on/off"
    device_class: light
    on_press:
      then:
        - light.turn_on: lcd
        - delay: 30s # время работы экрана
        - light.turn_off: lcd        

text_sensor:
  - platform: wifi_info
    ip_address:
      name: "${name} IP Address"
      icon: mdi:ip
      id: ip
    ssid:
      name: "${name} SSID"
      icon: mdi:access-point-network
    mac_address:
      name: "${name} Mac"
      icon: mdi:lan
  - platform: bme680_bsec
    iaq_accuracy:
      name: "${name} IAQ Accuracy"
  - platform: template
    name: "${name} IAQ Classification"
    icon: "mdi:checkbox-marked-circle-outline"
    lambda: |-
      uint16_t var = (id(bme680_iaq).state);
      switch (var) {
        case 0 ... 50: return std::string("Отлично");
        case 51 ... 100: return std::string("Хорошо");
        case 101 ... 150: return std::string("Слегка загрязненный");
        case 151 ... 200: return std::string("Умеренно загрязненный");
        case 201 ... 250: return std::string("Слегка загрязненный");
        case 251 ... 300: return std::string("Загрязненный");
        case 301 ... 350: return std::string("Сильно загрязненный");
        case 351 ... 500: return std::string("Черезвычайно загрязненный"); 
        default: return std::string("error");
      }      
sensor:
  - platform: internal_temperature
    name: "${name} ESP32 T"
  - platform: esp32_hall
    name: "${name} hall Sensor"
    update_interval: 60s

  - platform: wifi_signal
    name: "${name} Wifi"
    update_interval: 60s  
    id: wifi_signal_db
    entity_category: "diagnostic"
  - platform: copy # Reports the WiFi signal strength in %
    source_id: wifi_signal_db
    name: "${name} WiFi Percent"
    filters:
      - lambda: return min(max(2 * (x + 100.0), 0.0), 100.0);
    unit_of_measurement: "%"
    entity_category: "diagnostic"
    id: WiFiP

  - platform: bme680_bsec
    temperature:
      name: "${name} T"
      id: bme680_t
  #    filters:
  #    - calibrate_linear:
   #     - 0.0 -> 0.0
   #     - 26.7 -> 24.7
    pressure:
      name: "${name} P"
      id: bme680_p
      filters:  
        - lambda: return x * 0.75;
      unit_of_measurement: "mmHg"
    humidity:
      name: "${name} H"
      id: bme680_h
   #   filters:
  #    - calibrate_linear:
  #      - 0.0 -> 0.0
   #     - 52 -> 54.7
    iaq:
      name: "${name} IAQ"
      id: bme680_iaq
    iaq_accuracy:
     name: "${name}  IAQ Accuracy"
    co2_equivalent:
      name: "${name} CO₂"
      id: bme680_co2
    breath_voc_equivalent:
      name: "${name} VOC"
      id: bme680_voc
    gas_resistance:
      #Gas resistance in Ω
      name: "${name}  Gas Resistance"
      filters:
        - median

  - platform: copy # Pressure 1h
    source_id: bme680_p
    name: "${name} pressure 1h"
    id: pressure_1h
    filters:
      - median:
          window_size: 60 #1441
          send_every: 61 #1440
          send_first_at: 1


  - platform: bh1750
    name: "${name} Illuminance"
    id: i_clock
    address: 0x23
    update_interval: 10s

  - platform: absolute_humidity
    name: "${name} Absolute Humidity"
    temperature: bme680_t
    humidity: bme680_h

  - platform: pm1006k
    pm_1_0:   
      name: "PM 1.0"
      id: "pm1"
    pm_2_5:
      name: "PM 2.5"
      id: "pm2"
    pm_10_0:
      name: "PM 10"
      id: "pm10"
      unit_of_measurement: µg/m³
    update_interval: 30s

  - platform: template
    name: "${name} brightness"
    id: brightness
    update_interval: 20s
    internal: true
    lambda: |-
      uint16_t brig = (id(i_clock).state) *10;
      switch (brig) {
        case 0 ... 1: return 7; break;
        case 2 ... 4: return 8; break;
        case 5 ...7: return 9; break;
        case 8 ... 10: return 10; break;
        default: return 10; break;
      }
    on_value:
      then:
        - light.turn_on:
            id: lcd
            brightness: !lambda |-
              return id(brightness).state / 10.0; 

  - platform: sun
    name: "${name} Elevation" 
    type: elevation
    id: elevation                
fan:
  - platform: speed
    output: vent
    name: "vent"
    id: pmvent
    speed_count: 10 # Количество скоростеей вентилятора
    on_turn_on:
      lambda: |-
        id(vent_bin).publish_state(true);
    on_turn_off:
      lambda: |-
        id(vent_bin).publish_state(false); 
light:
 # - platform: monochromatic
  #  name: "vent"
 #   output: vent
   # id: pmvent
   # icon: "mdi:fan"
 #   internal: true

  - platform: monochromatic
    name: "light_LCD"
    id: lcd
    output: light_LCD
    icon: mdi:television-ambient-light
 #   internal: true
# Example output entry
output:
  - platform: esp32_dac
    id: vent
    pin: GPIO25 # D4 #GPIO16 #5 ножка контроллера
  - platform: ledc
    pin: D6 #GPIO19
    id: light_LCD  
    inverted: false
      
display:
  - platform: st7735
    model: "INITR_18BLACKTAB"
    reset_pin: GPIO0
    cs_pin: D0 #GPIO26
    dc_pin: D8 #GPIO5
    rotation: 0
    device_width: 128
    device_height: 160
    col_start: 0
    row_start: 0
    eight_bit_color: true
    update_interval: 1s
    id: my_display
    pages:
# Первая страница дисплея выводим качество воздуха, давление, цифровые часы, значок работы вентилятора,
# индикатор сонца над горизонтом, содержание пыли PM1 (не нормируется)
      - id: page1
        lambda: |- 

          it.line(0,35,30,35, white);
          it.line(98,35,128,35, white);
          it.line(64,0,64,25, white);
          it.print(0, 22, id(font11), white, "IAQ");
          it.print(92, 22, id(font11), white, "PRESS");

          it.line(0,130,22,130, white);          
          it.line(102,130,128,130, white); 
          
          // Цыфровые часы
          it.strftime(25, 136, id(SEG24), lyellow,"%H %M", id(sntp_time).now());
          static int i = 0;
          i++;
          if ((i % 2) == 0) 
            it.print(65, 136, id(SEG24),lyellow,":");
          it.print(0, 131, id(font11), lyellow, "TIME");

          // давление
          it.printf(70,0, id(SEG24), blue, "%3.0f", id(bme680_p).state);

          // качество воздуха
          it.printf(0, 0, id(SEG24), green, "%3.0f", id(bme680_iaq).state);

          //оформление центра
          it.printf(64, 80, id(SEG24), white, TextAlign::CENTER, "%.0f", id(pm1).state);
          it.print(64, 105, id(font11), white, TextAlign::CENTER, "ppm");
          it.print(64, 130, id(font11), white, TextAlign::CENTER, "PM1");
          
          // Индикатор сонца над горизонтом
          if ((id(elevation).state) > 0) {
            id(g_sun).next_frame();
            it.image(110, 140, id(g_sun), yellow);
            }
          else {
            it.image(110, 140, id(g_moon), white);
            id(g_moon).next_frame();
            }
          // Состояние вентилятора
          if (id(vent_bin).state) {
            it.image(0, 140, id(g_fan));
            id(g_fan).next_frame();
          }

          //  Размеры
          int centerX = 64; 
          int centerY = 85; 
          int radius = 60;
          int zradius = 55;
          int vradius = 46;
          int mradius = 40;
          int width = 3;

          // Большой белый
          //PI / 180 = 0.0174533
          for (int grad = 130; grad <= 175; grad++) {
            float radian = grad * 0.0174533;
            it.draw_pixel_at(centerX+radius*cos(radian), centerY+radius*sin(radian), white);
          }
          for (int grad = 185; grad <= 260; grad++) {
            float radian = grad * 0.0174533;
            it.draw_pixel_at(centerX+radius*cos(radian), centerY+radius*sin(radian), white);
          }
          for (int grad = 280; grad <= 355; grad++) {
            float radian = grad * 0.0174533;
            it.draw_pixel_at(centerX+radius*cos(radian), centerY+radius*sin(radian), white);
          }
          for (int grad = 365; grad <= 410; grad++) {
            float radian = grad * 0.0174533;
            it.draw_pixel_at(centerX+radius*cos(radian), centerY+radius*sin(radian), white);
          }

          // Малый белый
          for (int grad = 135; grad <= 405; grad++) {
            float radian = grad * 0.0174533;
            it.draw_pixel_at(centerX+mradius*cos(radian), centerY+mradius*sin(radian), white);
          }
          for (int grad = 60; grad <= 120; grad++) {
            //PI / 180 = 0.0174533 
            float radian = grad * 0.0174533;
            it.draw_pixel_at(centerX+mradius*cos(radian), centerY+mradius*sin(radian), white);
          }

          // Синий сопровождение
          for (int grad = 135; grad <= 410; grad++) {
            float radian = grad * 0.0174533;
            it.filled_circle(centerX+vradius*cos(radian), centerY+vradius*sin(radian), width, blue);
          }  
          // Значение PM1   
          if (id(pm1).state); {
            int zpm1 = 135;
            zpm1 = (id(pm1).state * 0.125 + 135);
            for (int grad = 135; grad <= (id(pm1).state * 0.125 + 135); grad++) {
              float radian = grad * 0.0174533;
              it.filled_circle(centerX+zradius*cos(radian), centerY+zradius*sin(radian), width, green);
            }  
          }  
# Вторая страница дисплея выводим температуру, влажность, цифровые часы, значок работы вентилятора,
# индикатор сонца над горизонтом, содержание пыли PM2.5 цвет изменяется в зависимости от уровня (нормируется)
      - id: page2
        lambda: |- 
          it.line(0,35,30,35, white);
          it.line(98,35,128,35, white);
          it.line(64,0,64,25, white);
          it.print(0, 22, id(font11), white, "TEMP");
          it.print(92, 22, id(font11), white, "HYDRO");

          it.line(0,130,22,130, white);          
          it.line(102,130,128,130, white); 
          
          // цифровые часы
          it.strftime(25, 136, id(SEG24), lyellow,"%H %M", id(sntp_time).now());
          static int i = 0;
          i++;
          if ((i % 2) == 0) 
            it.print(65, 136, id(SEG24),lyellow,":");
          it.print(0, 131, id(font11), lyellow, "TIME");
          
          // влажность
          it.printf(70,0, id(SEG24), blue, "%2.0f", id(bme680_h).state);
          it.print(110, 0, id(icon_font), blue, "\U0000f87e");
          
          // температура
          uint16_t vt = (id(bme680_t).state);
          float td;
          float tc = modf( vt, &td);
          it.printf(0, 0, id(SEG24), green, "%2.0f.", td);
          it.printf(40, 12, id(SEG12), green, "%1.0f", tc*10);
          it.print(38, 0, id(font11), green, "°С");

          // оформление центра
          it.printf(64, 80, id(SEG24), white, TextAlign::CENTER, "%.0f", id(pm2).state);
          it.print(64, 105, id(font11), white, TextAlign::CENTER, "ppm");
          it.print(64, 130, id(font11), white, TextAlign::CENTER, "PM2.5");

          // Индикатор сонца над горизонтом
          if ((id(elevation).state) > 0) {
            id(g_sun).next_frame();
            it.image(110, 140, id(g_sun), yellow);
            }
          else {
            it.image(110, 140, id(g_moon), white);
            id(g_moon).next_frame();
            }
          // Состояние вентилятора
          if (id(vent_bin).state) {
            it.image(0, 140, id(g_fan));
            id(g_fan).next_frame();
          }

          // Размеры
          int centerX = 64; 
          int centerY = 85; 
          int radius = 60;
          int zradius = 55;
          int vradius = 46;
          int mradius = 40;
          int width = 3;

          // Большой белый
          //PI / 180 = 0.0174533
          for (int grad = 130; grad <= 175; grad++) {
            float radian = grad * 0.0174533;
            it.draw_pixel_at(centerX+radius*cos(radian), centerY+radius*sin(radian), white);
          }
          for (int grad = 185; grad <= 260; grad++) {
            float radian = grad * 0.0174533;
            it.draw_pixel_at(centerX+radius*cos(radian), centerY+radius*sin(radian), white);
          }
          for (int grad = 280; grad <= 355; grad++) {
            float radian = grad * 0.0174533;
            it.draw_pixel_at(centerX+radius*cos(radian), centerY+radius*sin(radian), white);
          }
          for (int grad = 365; grad <= 410; grad++) {
            float radian = grad * 0.0174533;
            it.draw_pixel_at(centerX+radius*cos(radian), centerY+radius*sin(radian), white);
          }

          // Малый белый
          for (int grad = 135; grad <= 405; grad++) {
            float radian = grad * 0.0174533;
            it.draw_pixel_at(centerX+mradius*cos(radian), centerY+mradius*sin(radian), white);
          }
          for (int grad = 60; grad <= 120; grad++) {
            //PI / 180 = 0.0174533 
            float radian = grad * 0.0174533;
            it.draw_pixel_at(centerX+mradius*cos(radian), centerY+mradius*sin(radian), white);
          }

          // Цветное сопровождение значение/2+135 (начало)
          for (int grad = 135; grad <= 150; grad++) {
            float radian = grad * 0.0174533;
            it.filled_circle(centerX+vradius*cos(radian), centerY+vradius*sin(radian), width,  green);
          }  
          for (int grad = 151; grad <= 165; grad++) {
            float radian = grad * 0.0174533;
            it.filled_circle(centerX+vradius*cos(radian), centerY+vradius*sin(radian), width,  lgreen);
          }  
          for (int grad = 166; grad <= 180; grad++) {
            float radian = grad * 0.0174533;
            it.filled_circle(centerX+vradius*cos(radian), centerY+vradius*sin(radian), width,  yellow);
          } 
          for (int grad = 181; grad <= 195; grad++) {
            float radian = grad * 0.0174533;
            it.filled_circle(centerX+vradius*cos(radian), centerY+vradius*sin(radian), width,  lyellow);
          } 
          for (int grad = 196; grad <= 260; grad++) {
            float radian = grad * 0.0174533;
            it.filled_circle(centerX+vradius*cos(radian), centerY+vradius*sin(radian), width,  red);
          } 
          for (int grad = 261; grad <= 410; grad++) {
            float radian = grad * 0.0174533;
            it.filled_circle(centerX+vradius*cos(radian), centerY+vradius*sin(radian), width,  tred);
          } 

          // Значения PM2.5 значение/2+135 (начало)
          uint16_t vpm2 = (id(pm2).state);
          switch (vpm2) {
            case 0 ... 30:
              if (id(pm2).state); {
                for (int grad = 135; grad <= id(pm2).state *0.5 + 135; grad++) {
                  float radian = grad * 0.0174533;
                  it.filled_circle(centerX+zradius*cos(radian), centerY+zradius*sin(radian), width, green);
                }  
              }
              break;
            case 31 ... 60:
              if (id(pm2).state); {
                for (int grad = 135; grad <= id(pm2).state *0.5 + 135; grad++)  {
                  float radian = grad * 0.0174533;
                  it.filled_circle(centerX+zradius*cos(radian), centerY+zradius*sin(radian), width, lgreen);
                }  
              }
              break;
            case 61 ... 90: 
              if (id(pm2).state); {
                for (int grad = 135; grad <= id(pm2).state *0.5 + 135; grad++)  {
                  float radian = grad * 0.0174533;
                  it.filled_circle(centerX+zradius*cos(radian), centerY+zradius*sin(radian), width, yellow);
                }  
              }
              break;
            case 91 ... 120: 
              if (id(pm2).state); {
                for (int grad = 135; grad <= id(pm2).state *0.5 + 135; grad++)  {
                  float radian = grad * 0.0174533;
                  it.filled_circle(centerX+zradius*cos(radian), centerY+zradius*sin(radian), width, lyellow);
                }  
              }
              break;
            case 121 ... 250: 
              if (id(pm2).state); {
                for (int grad = 135; grad <= id(pm2).state *0.5 + 135; grad++)  {
                  float radian = grad * 0.0174533;
                  it.filled_circle(centerX+zradius*cos(radian), centerY+zradius*sin(radian), width, red);
                }  
              }
              break;
            case 251 ... 1000:
              if (id(pm2).state); {
                for (int grad = 135; grad <= id(pm2).state *0.5 + 135; grad++)  {
                  float radian = grad * 0.0174533;
                  it.filled_circle(centerX+zradius*cos(radian), centerY+zradius*sin(radian), width, tred);
                }  
              }
              break;
            default: 
              if (id(pm2).state); {
                for (int grad = 135; grad <= id(pm2).state *0.5 + 135; grad++) {
                  float radian = grad * 0.0174533;
                  it.filled_circle(centerX+zradius*cos(radian), centerY+zradius*sin(radian), width, blue);
                }  
              }
              break;              
          }
# Третья страница дисплея выводим содержание органических вешеств, углекислый газ, цифровые часы, значок работы вентилятора,
# индикатор сонца над горизонтом, содержание пыли PM10 цвет изменяется в зависимости от уровня (нормируется)          
      - id: page3
        lambda: |- 
          it.line(0,35,30,35, white);
          it.line(98,35,128,35, white);
          it.line(64,0,64,25, white);
          it.print(0, 22, id(font11), white, "VOC");
          it.print(92, 22, id(font11), white, "CO2");
          
          it.line(0,130,22,130, white);          
          it.line(102,130,128,130, white); 

          // цифровые часы
          it.strftime(25, 136, id(SEG24), lyellow,"%H %M", id(sntp_time).now());
          static int i = 0;
          i++;
          if ((i % 2) == 0) 
            it.print(65, 136, id(SEG24),lyellow,":");
          it.print(0, 131, id(font11), lyellow, "TIME");

          // углекислый газ
          it.printf(70,0, id(SEG24), blue, "%3.0f", id(bme680_co2).state);

          // органические вешества
          it.printf(0, 0, id(SEG24), green, "%3.0f", id(bme680_voc).state);

          // оформление центра
          it.printf(64, 80, id(SEG24), white, TextAlign::CENTER, "%.0f", id(pm10).state);
          it.print(64, 105, id(font11), white, TextAlign::CENTER, "ppm");
          it.print(64, 130, id(font11), white, TextAlign::CENTER, "PM10");

          // Индикатор сонца над горизонтом
          if ((id(elevation).state) > 0) {
            id(g_sun).next_frame();
            it.image(110, 140, id(g_sun), yellow);
            }
          else {
            it.image(110, 140, id(g_moon), white);
            id(g_moon).next_frame();
            }
          // Состояние вентилятора
          if (id(vent_bin).state) {
            it.image(0, 140, id(g_fan));
            id(g_fan).next_frame();
          }
          
          // Размеры
          int centerX = 64; 
          int centerY = 85; 
          int radius = 60;
          int zradius = 55;
          int vradius = 46;
          int mradius = 40;
          int width = 3;

          // Большой белый
          //PI / 180 = 0.0174533
          for (int grad = 130; grad <= 175; grad++) {
            float radian = grad * 0.0174533;
            it.draw_pixel_at(centerX+radius*cos(radian), centerY+radius*sin(radian), white);
          }
          for (int grad = 185; grad <= 260; grad++) {
            float radian = grad * 0.0174533;
            it.draw_pixel_at(centerX+radius*cos(radian), centerY+radius*sin(radian), white);
          }
          for (int grad = 280; grad <= 355; grad++) {
            float radian = grad * 0.0174533;
            it.draw_pixel_at(centerX+radius*cos(radian), centerY+radius*sin(radian), white);
          }
          for (int grad = 365; grad <= 410; grad++) {
            float radian = grad * 0.0174533;
            it.draw_pixel_at(centerX+radius*cos(radian), centerY+radius*sin(radian), white);
          }

          // Малый белый
          for (int grad = 135; grad <= 405; grad++) {
            float radian = grad * 0.0174533;
            it.draw_pixel_at(centerX+mradius*cos(radian), centerY+mradius*sin(radian), white);
          }
          for (int grad = 60; grad <= 120; grad++) {
            //PI / 180 = 0.0174533 
            float radian = grad * 0.0174533;
            it.draw_pixel_at(centerX+mradius*cos(radian), centerY+mradius*sin(radian), white);
          }


          // Цветное сопровождение значение/2+135 (начало)
          for (int grad = 135; grad <= 160; grad++) {
            float radian = grad * 0.0174533;
            it.filled_circle(centerX+vradius*cos(radian), centerY+vradius*sin(radian), width,  green);
          }  
          for (int grad = 161; grad <= 185; grad++) {
            float radian = grad * 0.0174533;
            it.filled_circle(centerX+vradius*cos(radian), centerY+vradius*sin(radian), width,  lgreen);
          }  
          for (int grad = 186; grad <= 260; grad++) {
            float radian = grad * 0.0174533;
            it.filled_circle(centerX+vradius*cos(radian), centerY+vradius*sin(radian), width,  yellow);
          } 
          for (int grad = 261; grad <= 310; grad++) {
            float radian = grad * 0.0174533;
            it.filled_circle(centerX+vradius*cos(radian), centerY+vradius*sin(radian), width,  lyellow);
          } 
          for (int grad = 310; grad <= 350; grad++) {
            float radian = grad * 0.0174533;
            it.filled_circle(centerX+vradius*cos(radian), centerY+vradius*sin(radian), width,  red);
          } 
          for (int grad = 351; grad <= 410; grad++) {
            float radian = grad * 0.0174533;
            it.filled_circle(centerX+vradius*cos(radian), centerY+vradius*sin(radian), width,  tred);
          } 

          // Значения PM10 значение/2+135 (начало)
          uint16_t vpm10 = (id(pm10).state);
          switch (vpm10) {
            case 0 ... 50:
              if (id(pm10).state); {
                for (int grad = 135; grad <= id(pm10).state *0.5 + 135; grad++) {
                  float radian = grad * 0.0174533;
                  it.filled_circle(centerX+zradius*cos(radian), centerY+zradius*sin(radian), width, green);
                }  
              }
              break;
            case 51 ... 100:
              if (id(pm10).state); {
                for (int grad = 135; grad <= id(pm10).state *0.5 + 135; grad++) {
                  float radian = grad * 0.0174533;
                  it.filled_circle(centerX+zradius*cos(radian), centerY+zradius*sin(radian), width, lgreen);
                }  
              }
              break;
            case 101 ... 250: 
              if (id(pm10).state); {
                for (int grad = 135; grad <= id(pm10).state *0.5 + 135; grad++){
                  float radian = grad * 0.0174533;
                  it.filled_circle(centerX+zradius*cos(radian), centerY+zradius*sin(radian), width, yellow);
                }  
              }
              break;
            case 251 ... 350: 
              if (id(pm10).state); {
                for (int grad = 135; grad <= id(pm10).state *0.5 + 135; grad++) {
                  float radian = grad * 0.0174533;
                  it.filled_circle(centerX+zradius*cos(radian), centerY+zradius*sin(radian), width, lyellow);
                }  
              }
              break;
            case 351 ... 430: 
              if (id(pm10).state); {
                for (int grad = 135; grad <= id(pm10).state *0.5 + 135; grad++) {
                  float radian = grad * 0.0174533;
                  it.filled_circle(centerX+zradius*cos(radian), centerY+zradius*sin(radian), width, red);
                }  
              }
              break;
            case 431 ... 1000:
              if (id(pm10).state); {
                for (int grad = 135; grad <= id(pm10).state *0.5 + 135; grad++) {
                  float radian = grad * 0.0174533;
                  it.filled_circle(centerX+zradius*cos(radian), centerY+zradius*sin(radian), width, tred);
                }  
              }
              break;
            default: 
              if (id(pm10).state); {
                for (int grad = 135; grad <= id(pm10).state *0.5 + 135; grad++) {
                  float radian = grad * 0.0174533;
                  it.filled_circle(centerX+zradius*cos(radian), centerY+zradius*sin(radian), width, blue);
                }  
              }
              break;              
          }
# Четвертая страница дисплея выводим значок работы вентилятора,индикатор сонца над горизонтом, стрелочные часы
      - id: page4
        lambda: |- 
          it.image(0, 0, id(clok));   
          auto timeY = id(sntp_time).now();

          // Индикатор сонца над горизонтом
          if ((id(elevation).state) > 0) {
            id(g_sun).next_frame();
            it.image(110, 140, id(g_sun), yellow);
            }
          else {
            it.image(110, 140, id(g_moon), white);
            id(g_moon).next_frame();
            }
          // Состояние вентилятора
          if (id(vent_bin).state) {
            it.image(0, 140, id(g_fan));
            id(g_fan).next_frame();
          }
          
          // Центр, радиус, толщина половины стрелки, отступы
          int centerX = 64; 
          int centerY = 80; 
          int radius = 64;
          int width = 3;
          int h_otstup = 25;
          int m_otstup = 10;
          int s_otstup = 10;
          int ns_otstup = 50;

          //hour, minute
          uint8_t dh = timeY.hour;
          uint8_t dm = timeY.minute;

          // Расчет верхней точки часовой стрелки (30 градусов на 1 час  (360/12)) с учетом минут
          float hsmv = (dh*30 + dm/2-90)* PI / 180;
          int hy = centerY+(radius-h_otstup)*sin(hsmv);
          int hx = centerX+(radius-h_otstup)*cos(hsmv);

          // Расчет нижней правой точки часовой стрелки (30 градусов на 1 час  (360/12))  
          float hsmp = (dh*30 + dm/2-180) * PI / 180;
          int hnpy = centerY+width*sin(hsmp);
          int hnpx = centerX+width*cos(hsmp);

          // Расчет нижней левой точки часовой стрелки (30 градусов на 1 час  (360/12)) 
          float hsml = (dh*30 + dm/2) * PI / 180;
          int hnly = centerY+width*sin(hsml);
          int hnlx = centerX+width*cos(hsml);

          // Одноцветная часовая стрелка
          // it.filled_triangle(hx, hy, hnlx, hnly, hnpx, hnpy, white);

          // Двух цветная часовая стрелка
          it.filled_triangle(hx, hy, centerX, centerY, hnpx, hnpy, green);
          it.filled_triangle(hx, hy, hnlx, hnly, centerX, centerY, yellow);


          //minut

          // Расчет верхней точки миутной стрелки 6 градусов на 1 минуту (360/60)
          float msmv = (dm*6-90)* PI / 180;
          int my = centerY+(radius-m_otstup)*sin(msmv);
          int mx = centerX+(radius-m_otstup)*cos(msmv);
  
          // Расчет нижней правой точки миутной стрелки 6 градусов на 1 минуту  (360/60)
          float msmp = (dm*6-180) * PI / 180;
          int mnpy = centerY+width*sin(msmp);
          int mnpx = centerX+width*cos(msmp);

          // Расчет нижней левой точки миутной стрелки  6 градусов на 1 минуту  (360/60)
          float msml = (dm*6) * PI / 180;
          int mnly = centerY+width*sin(msml);
          int mnlx = centerX+width*cos(msml);

          // Одноцветная минутная стрелка
          //it.filled_triangle(mx, my, mnlx, mnly, mnpx, mnpy, white);

          // Двух цветная минутная стрелка
          it.filled_triangle(mx, my, mnlx, mnly, centerX, centerY, yellow);
          it.filled_triangle(mx, my, centerX, centerY, mnpx, mnpy, green);


          //sec
          uint8_t ds = timeY.second;

          // Расчет верхней точки секундной стрелки 6 градусов на 1 секунду (360/60)
          float ssmv = (ds*6+270)* PI / 180;
          int sy = centerY+(radius-s_otstup)*sin(ssmv);
          int sx = centerX+(radius-s_otstup)*cos(ssmv);

          // Секундная стрелка
          it.line(centerX, centerY, sx, sy, tred);

          // Расчет нижней точки второй части секундной стрелки 6 градусов на 1 секунду (360/60)          
          int syz = centerY-(radius-ns_otstup)*sin(ssmv);
          int sxz = centerX-(radius-ns_otstup)*cos(ssmv);

          // Вторая нижняя часть секундной стрелки 
          it.line(centerX, centerY, sxz, syz, tred);

          // Точки по центру
          it.filled_circle(centerX, centerY, 5, white);
          it.filled_circle(centerX, centerY, 3,  tred);

# Пятая страница дисплея выводим барометр
      - id: page5
        lambda: |-
          it.image(0, 20, id(barometr)); 

          // Центр, радиус, верхний отступ стрелки, наконечник стрелки, грань наконечника стрелки, угол отклонения наконечника от стрелки 
          int centerX = 64; 
          int centerY = 80; 
          int radius = 64;
          int otstup = 10;
          int n_otstup = 50;
          int strel = 5;
          int gstrel = 10;
          // int gnstrel = 10;
          int nak_grad = 7;

          // Максимальное значение, минимальное значение, начало и конец зоны индикации в градусах
          float zmax = 800;
          int zmin = 700;
          // 90+45 градусов
          int n_grad = 135; 
          // 360+45 градусов
          int k_grad = 405;
          // расчет цены деления, расчет угла по показаниям датчика

          float shag =  (k_grad-n_grad) / (zmax - zmin);
          float grad_n = nak_grad * (PI / 180);

          ///////////////////////////////////////////////////////////////////////////////////
          if (id(pressure_1h).state != id(bme680_p).state) {

            float pressure_kor =0;
            if (id(pressure_1h).state > id(bme680_p).state) {
              pressure_kor = 10; 
            }
            else {
              pressure_kor = -10; 
            }

            float grad_ind_d = (n_grad + (id(pressure_1h).state - zmin + pressure_kor)*shag) *(PI / 180);

            // Верхняя точка вспомогательной стрелки
            int v_ind_y = centerY+(radius - otstup)*sin(grad_ind_d);
            int v_ind_x = centerX+(radius - otstup)*cos(grad_ind_d);

            // Нижняя точка наконечника вспомогательной стрелки
            int v_ind_y2 = centerY+(radius - (otstup + strel))*sin(grad_ind_d);
            int v_ind_x2 = centerX+(radius - (otstup + strel))*cos(grad_ind_d);

            // Нижняя левая точка наконечника вспомогательной стрелки
            int v_ind_yl = centerY+(radius - (otstup + gstrel))*sin(grad_ind_d - grad_n);
            int v_ind_xl = centerX+(radius - (otstup + gstrel))*cos(grad_ind_d - grad_n);

            // Нижняя правая точка наконечника вспомогательной стрелки
            int v_ind_yp = centerY+(radius - (otstup + gstrel))*sin(grad_ind_d + grad_n);
            int v_ind_xp = centerX+(radius - (otstup + gstrel))*cos(grad_ind_d + grad_n);

            //Наконечник  вспомогательной стрелки левая часть
            it.filled_triangle(v_ind_x, v_ind_y, v_ind_xl, v_ind_yl, v_ind_x2, v_ind_y2, white);

            //Наконечник  вспомогательной стрелки правая часть
            it.filled_triangle(v_ind_x, v_ind_y, v_ind_xp, v_ind_yp, v_ind_x2, v_ind_y2, white);

            // вспомогательная стрелка 
            it.line(centerX, centerY, v_ind_x2, v_ind_y2, white);

            // Расчет нижней точки второй части  вспомогательной стрелки       
            int v_ind_yn = centerY-(radius-n_otstup)*sin(grad_ind_d);
            int v_ind_xn = centerX-(radius-n_otstup)*cos(grad_ind_d);

            // Нижняя левая точка  нижнего наконечника  вспомогательной стрелки
            int v_ind_ynl = centerY-(radius - (n_otstup - gstrel))*sin(grad_ind_d - grad_n);
            int v_ind_xnl = centerX-(radius - (n_otstup - gstrel))*cos(grad_ind_d - grad_n);

            // Нижняя правая точка нижего наконечника  вспомогательной стрелки
            int v_ind_ynp = centerY-(radius - (n_otstup - gstrel))*sin(grad_ind_d + grad_n);
            int v_ind_xnp = centerX-(radius - (n_otstup - gstrel))*cos(grad_ind_d + grad_n);

            // Вторая нижняя часть вспомогательной стрелки 
            it.line(centerX, centerY, v_ind_xn, v_ind_yn, white);

            //Наконечник нижние  вспомогательной стрелки  
            it.filled_triangle(v_ind_xn, v_ind_yn, v_ind_xnl, v_ind_ynl, v_ind_xnp, v_ind_ynp, white);
          }

          ///////////////////////////////////////////////////////////////////////////////////    
          if (id(bme680_p).state > 0) {
            float grad_ind = ((id(bme680_p).state - zmin) * shag + n_grad) *(PI/180);
            // Верхняя точка стрелки
            int ind_y = centerY+(radius - otstup)*sin(grad_ind);
            int ind_x = centerX+(radius - otstup)*cos(grad_ind);

            // Нижняя точка наконечника стрелки
            int ind_y2 = centerY+(radius - (otstup + strel))*sin(grad_ind);
            int ind_x2 = centerX+(radius - (otstup + strel))*cos(grad_ind);

            // Нижняя левая точка наконечника стрелки
            int ind_yl = centerY+(radius - (otstup + gstrel))*sin(grad_ind - grad_n);
            int ind_xl = centerX+(radius - (otstup + gstrel))*cos(grad_ind - grad_n);

            // Нижняя правая точка наконечника стрелки
            int ind_yp = centerY+(radius - (otstup + gstrel))*sin(grad_ind + grad_n);
            int ind_xp = centerX+(radius - (otstup + gstrel))*cos(grad_ind + grad_n);

            //Наконечник стрелки левая часть
            it.filled_triangle(ind_x, ind_y, ind_xl, ind_yl, ind_x2, ind_y2, tred);

            //Наконечник стрелки правая часть
            it.filled_triangle(ind_x, ind_y, ind_xp, ind_yp, ind_x2, ind_y2, tred);

            //Стрелка 
            it.line(centerX, centerY, ind_x2, ind_y2, tred);

            // Расчет нижней точки второй части стрелки       
            int ind_yn = centerY-(radius-n_otstup)*sin(grad_ind);
            int ind_xn = centerX-(radius-n_otstup)*cos(grad_ind);

            // Нижняя левая точка  нижнего наконечника стрелки
            int ind_ynl = centerY-(radius - (n_otstup - gstrel))*sin(grad_ind - grad_n);
            int ind_xnl = centerX-(radius - (n_otstup - gstrel))*cos(grad_ind - grad_n);

            // Нижняя правая точка нижего наконечника стрелки
            int ind_ynp = centerY-(radius - (n_otstup - gstrel))*sin(grad_ind + grad_n);
            int ind_xnp = centerX-(radius - (n_otstup - gstrel))*cos(grad_ind + grad_n);

            // Вторая нижняя часть  стрелки 
            it.line(centerX, centerY, ind_xn, ind_yn, tred);

            //Наконечник нижние стрелки  
            it.filled_triangle(ind_xn, ind_yn, ind_xnl, ind_ynl, ind_xnp, ind_ynp, tred);
          }

interval:
  - interval: 5s
    then:
      - display.page.show_next: my_display
      - component.update: my_display 

web_server:
  version: 3
  port: 80
  auth:
    username: !secret web_user
    password: !secret web_pass         

time:
  - platform: sntp
    id: sntp_time
    servers:
     - 0.pool.ntp.org
    on_time: 
# Время включения вентилятора      
      - seconds: 0
        then:
          - fan.turn_on:
              id: pmvent
              speed: 7 # скорость вентилятора 70%
# изменение скорости врашения              
           #   brightness: !lambda |-
           #     return id(brightness).state / 10.0;   
  # - output.set_level:
   #     id: dac_output
   #     level: 50%

# Время запроса данных pm1006k                       
#      - seconds: 30
#        then:
#          - uart.write:
#              id: PM1006
#              data: [0x11, 0x02, 0x0B, 0x01, 0xE1]
# Время выключения вентилятора                  
      - seconds: 32
        then:
          - fan.turn_off:
              id: pmvent
